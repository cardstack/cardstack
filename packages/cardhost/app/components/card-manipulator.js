import Component from '@glimmer/component';
import { action } from '@ember/object';
import { tracked } from '@glimmer/tracking';
import { inject as service } from '@ember/service';
import { task, timeout } from 'ember-concurrency';
import { restartableTask } from 'ember-concurrency-decorators';
import ENV from '@cardstack/cardhost/config/environment';
import { fieldCards } from '../utils/scaffolding';
import cloneDeep from 'lodash/cloneDeep';
import drag from '../motions/drag';
import move from 'ember-animated/motions/move';
import scaleBy from '../motions/scale';
import { parallel } from 'ember-animated';
import { fadeOut } from 'ember-animated/motions/opacity';
import { easeIn, easeOut } from 'ember-animated/easings/cosine';

const { environment, clickDragDebounceMs, animationSpeed } = ENV;
const CLICK_DRAG_DEBOUNCE_MS = 100; // ¯\_(ツ)_/¯
const DURATION = animationSpeed || 500;

export default class CardManipulator extends Component {
  @service data;
  @service autosave;
  @service router;
  @service cardstackSession;
  @service cssModeToggle;
  @service draggable;

  @tracked statusMsg;
  @tracked card;
  @tracked catalogEntries;
  @tracked parentCard;
  @tracked grandParentCard;
  @tracked selectedField;
  @tracked selectedFieldName;
  @tracked selectedFieldType;
  @tracked isDragging;
  @tracked cardId;
  @tracked cardSelected = true;
  @tracked fieldOrderPromise;
  @tracked isolatedCss;
  @tracked stopMouse;
  @tracked updateMouse;
  @tracked justDropped;

  clickDragDebounce = clickDragDebounceMs || CLICK_DRAG_DEBOUNCE_MS;
  duration = DURATION;

  constructor(...args) {
    super(...args);

    this.originalCard = this.args.card;
    this.load.perform();
  }

  get cardJson() {
    if (!this.args.card) {
      return null;
    }
    return JSON.stringify(this.args.card.document.jsonapi, null, 2);
  }

  @(task(function*() {
    /**
      Returns field name in the form field-12, incrementing from the highest
      existing field number. Ex: if the highest is field-15, this will return
      field-16. If there are no fields, it returns field-1.
    */
    let existingFields = yield this.args.card.fields();
    let autogeneratedFieldNames = existingFields.map(field => field.name).filter(name => /^field-\d+$/.test(name));
    let fieldNumbers = autogeneratedFieldNames.map(item => Number(item.split('-')[1]));
    let newNumber = fieldNumbers.length ? Math.max(...fieldNumbers) + 1 : 1;
    return `field-${newNumber}`;
  }).drop())
  getNewFieldName;

  @(task(function*(fieldCard, position, evt) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let doc = this.args.card.document;

    let fieldName = yield this.getNewFieldName.perform();
    let isolatedFields = yield this.args.card.fields({ includeFieldSet: 'isolated' });
    let embeddedFields = yield this.args.card.fields({ includeFieldSet: 'embedded' });
    let csFieldSets = { isolated: isolatedFields.map(f => f.name), embedded: embeddedFields.map(f => f.name) };

    let csFieldOrder = [...(this.args.card.csFieldOrder || [])];
    csFieldOrder.splice(position, 0, fieldName);
    csFieldSets.isolated = csFieldSets.isolated || [];
    csFieldSets.isolated.push(fieldName);

    doc.withField(fieldName, fieldCard).withAttributes({ csFieldSets, csFieldOrder });
    let patchedCard = yield this.patchCard.perform(doc);
    let field = yield patchedCard.field(fieldName);

    if (this.fieldOrderResolve) {
      this.fieldOrderResolve();
    }
    yield this.selectField.perform(field, evt);
  }).enqueue())
  addField;

  @(task(function*(fieldName, newPosition, evt) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let doc = this.args.card.document;
    let csFieldOrder = [...(this.args.card.csFieldOrder || [])];
    csFieldOrder = csFieldOrder.filter(i => i !== fieldName);
    csFieldOrder.splice(newPosition, 0, fieldName);

    doc.withAttributes({ csFieldOrder });
    let patchedCard = yield this.patchCard.perform(doc);
    let field = yield patchedCard.field(fieldName);

    if (this.fieldOrderResolve) {
      this.fieldOrderResolve();
    }
    yield this.selectField.perform(field, evt);
  }).drop())
  setPosition;

  @(task(function*() {
    if (!this.selectedField) {
      return;
    }

    let fieldType = yield this.selectedField.adoptsFrom();
    this.selectedFieldType = fieldType.csTitle;
  }).restartable())
  loadSelectedField;

  @task(function*() {
    let [catalogEntries, parentCard, isolatedCss] = yield Promise.all([
      fieldCards(this.data),
      this.args.card.adoptsFrom(),
      this.args.card.loadFeature('isolated-css'),
    ]);

    this.catalogEntries = catalogEntries;
    this.parentCard = parentCard;
    this.isolatedCss = isolatedCss; // this is for the themer specifically
    if (parentCard) {
      this.grandParentCard = yield parentCard.adoptsFrom();
    }
  })
  load;

  @(task(function*(doc) {
    let updatedCard = yield this.args.card.patch(doc.jsonapiWithoutMeta);
    this.autosave.cardUpdated(updatedCard, true);
    return updatedCard;
  }).enqueue())
  patchCard;

  @task(function*() {
    yield this.data.delete(this.args.card);
    this.router.transitionTo('index');
  })
  deleteCard;

  @(task(function*(oldFieldName, newFieldName) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let field = yield this.args.card.field(oldFieldName);
    let doc = this.args.card.document;
    let csFieldOrder = [...(this.args.card.csFieldOrder || [])];

    let index = csFieldOrder.indexOf(oldFieldName);
    if (index !== -1) {
      csFieldOrder[index] = newFieldName;
    }

    doc
      .withoutField(oldFieldName)
      .withField(newFieldName, field.document, field.csFieldArity)
      .withAttributes({ csFieldOrder });

    if (this.args.card.csFieldSets) {
      let csFieldSets = cloneDeep(this.args.card.csFieldSets);
      for (let format of ['isolated', 'embedded']) {
        if (Array.isArray(csFieldSets[format]) && csFieldSets[format].includes(oldFieldName)) {
          csFieldSets[format] = [...csFieldSets[format].filter(i => i !== oldFieldName), newFieldName];
        }
      }
      doc.withAttributes({ csFieldSets });
    }

    yield this.patchCard.perform(doc);
    this.selectedFieldName = newFieldName;
  }).restartable())
  setFieldName;

  @(task(function*(fieldName, property, value) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let field = yield this.args.card.field(fieldName);
    let doc = this.args.card.document.withField(fieldName, field.document, field.csFieldArity, {
      [property]: value,
    });
    yield this.patchCard.perform(doc);
  }).restartable())
  setFieldCardValue;

  @(task(function*(field, value) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let doc = this.args.card.document.withAttributes({
      [field]: value,
    });
    yield this.patchCard.perform(doc);
  }).restartable())
  setCardValue;

  @(task(function*(field, cardId) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let doc = this.args.card.document.withRelationships({
      [field]: cardId,
    });
    yield this.patchCard.perform(doc);
  }).restartable())
  setCardReference;

  @(task(function*(fieldName, neededWhenEmbedded) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let doc = this.args.card.document;
    let isolatedFields = yield this.args.card.fields({ includeFieldSet: 'isolated' });
    let embeddedFields = yield this.args.card.fields({ includeFieldSet: 'embedded' });
    let csFieldSets = { isolated: isolatedFields.map(f => f.name), embedded: embeddedFields.map(f => f.name) };

    if (neededWhenEmbedded && Array.isArray(csFieldSets.embedded) && !csFieldSets.embedded.includes(fieldName)) {
      csFieldSets.embedded.push(fieldName);
    } else if (!neededWhenEmbedded && Array.isArray(csFieldSets.embedded) && csFieldSets.embedded.includes(fieldName)) {
      csFieldSets.embedded = csFieldSets.embedded.filter(i => i !== fieldName);
    }

    doc.withAttributes({ csFieldSets });

    yield this.patchCard.perform(doc);
  }).restartable())
  setNeededWhenEmbedded;

  @(task(function*(fieldName) {
    if (this.autosave.saveCard.last) {
      yield this.autosave.saveCard.last.then();
    }
    let doc = this.args.card.document;
    let csFieldOrder = [...(this.args.card.csFieldOrder || [])];

    csFieldOrder = csFieldOrder.filter(i => i !== fieldName);
    doc.withoutField(fieldName).withAttributes({ csFieldOrder });

    if (this.args.card.csFieldSets) {
      let csFieldSets = cloneDeep(this.args.card.csFieldSets);
      for (let format of ['isolated', 'embedded']) {
        if (Array.isArray(csFieldSets[format]) && csFieldSets[format].includes(fieldName)) {
          csFieldSets[format] = [...csFieldSets[format].filter(i => i !== fieldName)];
        }
      }
      doc.withAttributes({ csFieldSets });
    }

    yield this.patchCard.perform(doc);
    if ((this.selectedField && this.selectedField.name === fieldName) || this.selectedFieldName === fieldName) {
      this.cardSelected = true;
      this.selectedFieldName = null;
      this.selectedField = null;
      this.selectedFieldType = null;
    }
  }).drop())
  removeField;

  @action
  preview() {
    this.router.transitionTo('cards.card.edit.layout', this.args.card.canonicalURL);
  }

  @action
  delete() {
    this.deleteCard.perform();
  }

  @action
  initDrag() {
    this.isDragging = true;
  }

  @action dropField(position, onFinishDrop, evt) {
    if (this.fieldOrderResolve) {
      this.fieldOrderResolve();
    }
    // This is to address race conditions around the asynchronicity of creating
    // a new field and removing the "drop shadow" of the field to be dropped. We
    // are providing the card-renderer a promise for the patching of the card
    // with a new field, as well as the ability to see the state of the promise
    // before it tries to await the promise which is important to get the timing
    // of the shadow disappearance correct.
    this.fieldOrderPromise = queryablePromise(
      new Promise(resolve => {
        this.fieldOrderResolve = resolve;
      })
    );

    let droppedField = this.draggable.getField();
    if (!droppedField) {
      return;
    }

    onFinishDrop();
    let isMovedField =
      droppedField.enclosingCard && droppedField.enclosingCard.canonicalURL === this.args.card.canonicalURL;
    if (!isMovedField) {
      this.addField.perform(droppedField, position, evt);
    } else {
      let startPosition = this.draggable.getStartingPosition();
      if (droppedField.name && startPosition != null) {
        let newPosition = startPosition < position ? position - 1 : position;
        this.setPosition.perform(droppedField.name, newPosition, evt);
      }
    }

    this.draggable.clearField();
    this.draggable.clearDropzone();
    this.draggable.setDragging(false);
  }

  @(task(function*(field, evt) {
    // Toggling the selected field in tests is baffling me, using something more brute force
    if (environment === 'test' && this.selectedField === field) {
      return;
    }

    // we have to focus the clicked element to take focus away from the card.
    // to do that we have to give the element tabindex = 0 temporarily.
    // but if the element already has a tabindex (i.e. an input), we need
    // to make sure not to clobber it's original tabindex
    let tabIndex = evt.target.tabIndex;
    if (tabIndex === -1) {
      evt.target.tabIndex = 0;
      evt.target.focus();
      evt.target.blur();
      evt.target.tabIndex = tabIndex;
    } else {
      evt.target.focus();
    }

    this.selectedField = field;
    // I'm treating both the selectedField and the selectedFieldName separately
    // because renaming a field creates a whole new field instance, which has
    // some really awkward animation side effects--so renamed fields still
    // operate against the older field instance (from before the rename). This
    // is _not_ ideal.... A better approach would be to use a modal to prompt a
    // user for the field name when they change it. Then things would look much
    // more consistent when the new field is instantiated.
    this.selectedFieldName = null;
    this.cardSelected = false;
    yield this.loadSelectedField.perform();
  }).restartable())
  selectField;

  @action
  selectFieldType(field, event) {
    if (!this.draggable.isDragging && !this.justDropped) {
      this.beginDragging.perform(field, event);
    } else {
      this.draggable.setDragging(false);
    }
  }

  @restartableTask
  *beginDragging(field, dragEvent) {
    // we're clicking on a draggable that's already being dragged
    if (this.draggable.isDragging) {
      return;
    }

    // if the user clicks, the initial mousedown event will occur
    // first, wait for the mousedown -> mouseup -> click sequence
    // to happen before doing all the work
    yield timeout(this.clickDragDebounce);

    let dragState;
    let self = this;

    // WARNING! we do a lot of monkey patching of the FieldCard API below--this
    // is super dangerous because the API is immutable, and there is no
    // guarantee that the field instance isn't thrown away be the time you need
    // to get the value that you slapped on it. We really need to figure out a
    // different approach than setting arbitrary values on the FieldCard.
    function stopMouse() {
      field.dragState = dragState = null;
      let dropzone = self.draggable.getDropzone();
      if (dropzone) {
        self.draggable.drop();
        field.dropTo = dropzone;

        // this tells the click event that follows not to do anything
        self.justDropped = true;
        setTimeout(function() {
          self.justDropped = false;
        }, 1000);
      } else {
        // we mouseup somewhere that isn't a dropzone
      }
      self.draggable.clearField();

      // WARNING! we monkey patched the immutable card instances in the catalog.
      // There is no guarantee that state you set on these instances is carried
      // forward. This is working against our card API.

      // we do this so that we can animate the field back to the left edge.
      self.catalogEntries = self.catalogEntries.map(i => i);

      // remove ghost element from DOM
      let ghostEl = document.getElementById('ghost-element');
      if (ghostEl) {
        ghostEl.remove();
      }

      window.removeEventListener('mousemove', updateMouse, false);
      window.removeEventListener('mouseup', stopMouse, false);
      return false;
    }

    function updateMouse(event) {
      dragState.latestPointerX = event.x;
      dragState.latestPointerY = event.y;

      self.draggable.setDragging(true);

      let elemsBelow = document.elementsFromPoint(event.clientX, event.clientY);

      // this can happen when you drag the mouse outside the viewport
      if (!elemsBelow.length) {
        return;
      }

      let dropzoneBelow = elemsBelow.find(el => el.classList.contains('drop-zone'));
      let currentDropzone = self.draggable.getDropzone();

      if (currentDropzone !== dropzoneBelow) {
        if (currentDropzone) {
          self.draggable.clearDropzone();
        }
        if (dropzoneBelow) {
          self.draggable.setDropzone(dropzoneBelow);
        }
      }
    }

    if (dragEvent instanceof KeyboardEvent) {
      // This is a keyboard-controlled "drag" instead of a real mouse
      // drag.
      dragState = {
        usingKeyboard: true,
        xStep: 0,
        yStep: 0,
      };
    } else {
      dragState = {
        usingKeyboard: false,
        initialPointerX: dragEvent.x,
        initialPointerY: dragEvent.y,
        latestPointerX: dragEvent.x,
        latestPointerY: dragEvent.y,
      };
      window.addEventListener('mouseup', stopMouse, false);
      window.addEventListener('mousemove', updateMouse, false);
    }

    // WARNING! this is not good. we should not be monkey patching our immutable
    // card API with this stuff. There is no guarantee that things that you set
    // are carried forward as the cards are patched.
    field.dragState = dragState;

    this.draggable.setField(field);
    this.catalogEntries = this.catalogEntries.map(i => i);
  }

  *transition({ keptSprites }) {
    let activeSprite = keptSprites.find(sprite => sprite.owner.value.dragState);
    let others = keptSprites.filter(sprite => sprite !== activeSprite);

    if (activeSprite) {
      drag(activeSprite, {
        others,
      });
      let ghostElement = getGhostFromSprite(activeSprite);
      activeSprite.element.parentElement.appendChild(ghostElement);
      others.forEach(move);
    } else {
      let droppedSprite = keptSprites.find(sprite => sprite.owner.value.dropTo);
      if (droppedSprite) {
        let scaleTo = 0.1;
        let dropZoneEl = droppedSprite.owner.value.dropTo;
        let position = parseInt(dropZoneEl.dataset.dropZonePosition) + 1;
        let targetField = document.querySelector(
          `.isolated-card section:nth-of-type(${position}) .schema-field-renderer`
        );
        let { width, height } = targetField.getBoundingClientRect();
        droppedSprite.endTranslatedBy(((1 - scaleTo) / 2) * width, ((1 - scaleTo) / 2) * height);
        yield parallel(scaleBy(droppedSprite, { by: scaleTo }), move(droppedSprite), fadeOut(droppedSprite));
        droppedSprite.owner.value.dropTo = null;
      } else {
        others.forEach(move);
      }
    }
  }

  *catalogTransition({ insertedSprites, removedSprites, duration }) {
    for (let sprite of insertedSprites) {
      sprite.startAtPixel({ x: -window.innerWidth });
      move(sprite, { easing: easeOut, duration });
    }

    for (let sprite of removedSprites) {
      sprite.endAtPixel({ x: -window.innerWidth });
      move(sprite, { easing: easeIn, duration });
    }
  }
}

function getGhostFromSprite(sprite) {
  let ghostElement = sprite.element.cloneNode(true);
  for (let [key, value] of Object.entries(sprite.initialComputedStyle)) {
    ghostElement.style[key] = value;
  }
  let { top, left } = sprite.initialBounds;
  ghostElement.style.position = 'fixed';
  ghostElement.style.top = top;
  ghostElement.style.left = left;
  ghostElement.style.zIndex = '0';
  ghostElement.style.opacity = '0.4';
  ghostElement.id = 'ghost-element';

  return ghostElement;
}

function queryablePromise(promise) {
  if (promise.isResolved) return promise;

  let isPending = true;
  let isRejected = false;
  let isFulfilled = false;

  let result = promise.then(
    resolve => {
      isFulfilled = true;
      isPending = false;
      return resolve;
    },
    reject => {
      isRejected = true;
      isPending = false;
      throw reject;
    }
  );

  result.isFulfilled = function() {
    return isFulfilled;
  };
  result.isPending = function() {
    return isPending;
  };
  result.isRejected = function() {
    return isRejected;
  };
  return result;
}
