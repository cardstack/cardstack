/* eslint no-process-exit: "off" */
import { readFile, writeFile } from 'fs/promises';
import path from 'path';
import { buildYargs } from '../builder';

// This script extracts the command usage from yargs and updates the README.md file to include it

(async () => {
  process.env.BUILDING_README = '1';
  let commandInfos = await extractCommandInfo();
  let markdown = createMarkdown(commandInfos);
  let readMePath = path.resolve(__dirname, '../README.md');
  let readmeText = (await readFile(readMePath, 'utf8')).toString();
  readmeText = replaceInBetweenComments(
    readmeText,
    '<!-- BEGIN CLI DOCS GENERATED BY yarn command-docs -->',
    '<!-- END CLI DOCS GENERATED BY yarn command-docs -->',
    markdown
  );
  await writeFile('./README.md', readmeText);
  process.exit(0);
})().catch((e) => {
  console.error(e);
  process.exit(1);
});

interface CommandInfo {
  usage: string;
  helpText: string;
}

async function extractCommandInfo(helpOutput: string | undefined = undefined): Promise<CommandInfo[]> {
  if (!helpOutput) {
    let topLevelHelp = await buildYargs([]).wrap(null).getHelp();
    return extractCommandInfo(topLevelHelp);
  }
  const commandSection = helpOutput.split('\n\n').find((section) => section.startsWith('Commands:'));
  let result = [] as CommandInfo[];
  if (commandSection) {
    let entries = commandSection
      .split('\n')
      .filter((line) => line.trim() !== 'Commands:')
      .map((line) => {
        return line.split(/ {2,}/).filter(Boolean);
      });
    for (const [usage] of entries) {
      if (usage.endsWith('<command>')) {
        let subcommand = usage.replace(/^cardpay (.+) <command>$/, '$1');
        let subcommandHelp = await buildYargs(subcommand.split(' ')).wrap(null).getHelp();
        let subCommandResults = await extractCommandInfo(subcommandHelp);
        result = result.concat(subCommandResults);
      } else {
        let leafCommand = usage.replace(/^cardpay ((?:[a-z0-9-]+ ?)+).*$/, '$1').trim();
        let leafCommandHelp = await buildYargs(leafCommand.split(' ')).wrap(null).getHelp();
        result.push({ usage: leafCommand, helpText: leafCommandHelp });
      }
    }
  }
  return result;
}

function createMarkdown(commandInfos: CommandInfo[]) {
  let result = 'Quick links:\n\n';
  for (const { helpText } of commandInfos) {
    let usage = helpText.split('\n')[0].trim();
    result += ` - [\`${usage}\`](#${usage
      .replace(/ /g, '-')
      .replace(/[<>[\]]/g, '')
      .toLowerCase()})\n`;
  }

  result += '\n\n';

  for (const { helpText } of commandInfos) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    let [usage, _blank1, description, _blank2, ...details] = helpText.split('\n');
    result += `## \`${usage}\`\n\n`;
    result += `${description}\n\n`;
    result += '```\n';
    result += `${details.filter(shouldIncludeDetailLine).join('\n')}\n`;
    result += '```\n\n';
  }
  return result;
}

function shouldIncludeDetailLine(line: string) {
  return !line.includes('--help') && !line.includes('--version');
}

function replaceInBetweenComments(text: string, startComment: string, endComment: string, textToInsert: string) {
  let startIndex = text.indexOf(startComment);
  let endIndex = text.indexOf(endComment);
  if (startIndex === -1 || endIndex === -1) {
    throw new Error(`Could not find ${startComment} or ${endComment} in text`);
  }
  let start = text.substring(0, startIndex);
  let end = text.substring(endIndex + endComment.length);
  return start + startComment + textToInsert + endComment + end;
}
